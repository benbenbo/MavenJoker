Index: src/main/java/com/zzb/test/RBTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.zzb.test;\r\n\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\n/**\r\n * 红黑树实现\r\n */\r\npublic class RBTree<T extends Comparable<T>> {\r\n    class RBTreeNode<T> {\r\n        private T value;//node value\r\n        private RBTreeNode<T> left;//left child pointer\r\n        private RBTreeNode<T> right;//right child pointer\r\n        private RBTreeNode<T> parent;//parent pointer\r\n        private boolean red;//color is red or not red\r\n\r\n        public RBTreeNode(){}\r\n        public RBTreeNode(T value){this.value=value;}\r\n        public RBTreeNode(T value,boolean isRed){this.value=value;this.red = isRed;}\r\n\r\n        public T getValue() {\r\n            return value;\r\n        }\r\n        void setValue(T value) {\r\n            this.value = value;\r\n        }\r\n        RBTreeNode<T> getLeft() {\r\n            return left;\r\n        }\r\n        void setLeft(RBTreeNode<T> left) {\r\n            this.left = left;\r\n        }\r\n        RBTreeNode<T> getRight() {\r\n            return right;\r\n        }\r\n        void setRight(RBTreeNode<T> right) {\r\n            this.right = right;\r\n        }\r\n        RBTreeNode<T> getParent() {\r\n            return parent;\r\n        }\r\n        void setParent(RBTreeNode<T> parent) {\r\n            this.parent = parent;\r\n        }\r\n        boolean isRed() {\r\n            return red;\r\n        }\r\n        boolean isBlack(){\r\n            return !red;\r\n        }\r\n        /**\r\n         * is leaf node\r\n         **/\r\n        boolean isLeaf(){\r\n            return left==null && right==null;\r\n        }\r\n\r\n        void setRed(boolean red) {\r\n            this.red = red;\r\n        }\r\n\r\n        void makeRed(){\r\n            red=true;\r\n        }\r\n        void makeBlack(){\r\n            red=false;\r\n        }\r\n        @Override\r\n        public String toString(){\r\n            return value.toString();\r\n        }\r\n    }\r\n    private final RBTreeNode<T> root;\r\n    //node number\r\n    private java.util.concurrent.atomic.AtomicLong size =\r\n            new java.util.concurrent.atomic.AtomicLong(0);\r\n\r\n    //in overwrite mode,all node's value can not  has same    value\r\n    //in non-overwrite mode,node can have same value, suggest don't use non-overwrite mode.\r\n    private volatile boolean overrideMode=true;\r\n\r\n    public RBTree(){\r\n        this.root = new RBTreeNode<T>();\r\n    }\r\n\r\n    public RBTree(boolean overrideMode){\r\n        this();\r\n        this.overrideMode=overrideMode;\r\n    }\r\n\r\n\r\n    public boolean isOverrideMode() {\r\n        return overrideMode;\r\n    }\r\n\r\n    public void setOverrideMode(boolean overrideMode) {\r\n        this.overrideMode = overrideMode;\r\n    }\r\n\r\n    /**\r\n     * number of tree number\r\n     * @return\r\n     */\r\n    public long getSize() {\r\n        return size.get();\r\n    }\r\n    /**\r\n     * get the root node\r\n     * @return\r\n     */\r\n    private RBTreeNode<T> getRoot(){\r\n        return root.getLeft();\r\n    }\r\n\r\n    /**\r\n     * add value to a new node,if this value exist in this tree,\r\n     * if value exist,it will return the exist value.otherwise return null\r\n     * if override mode is true,if value exist in the tree,\r\n     * it will override the old value in the tree\r\n     *\r\n     * @param value\r\n     * @return\r\n     */\r\n    public T addNode(T value){\r\n        RBTreeNode<T> t = new RBTreeNode<T>(value);\r\n        return addNode(t);\r\n    }\r\n    /**\r\n     * find the value by give value(include key,key used for search,\r\n     * other field is not used,@see compare method).if this value not exist return null\r\n     * @param value\r\n     * @return\r\n     */\r\n    public T find(T value){\r\n        RBTreeNode<T> dataRoot = getRoot();\r\n        while(dataRoot!=null){\r\n            int cmp = dataRoot.getValue().compareTo(value);\r\n            if(cmp<0){\r\n                dataRoot = dataRoot.getRight();\r\n            }else if(cmp>0){\r\n                dataRoot = dataRoot.getLeft();\r\n            }else{\r\n                return dataRoot.getValue();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    private T addNode(RBTreeNode<T> node){\r\n        node.setLeft(null);\r\n        node.setRight(null);\r\n        node.setRed(true);\r\n        setParent(node,null);\r\n        if(root.getLeft()==null){\r\n            root.setLeft(node);\r\n            //root node is black\r\n            node.setRed(false);\r\n            size.incrementAndGet();\r\n        }else{\r\n            RBTreeNode<T> x = findParentNode(node);\r\n            int cmp = x.getValue().compareTo(node.getValue());\r\n\r\n            if(this.overrideMode && cmp==0){\r\n                T v = x.getValue();\r\n                x.setValue(node.getValue());\r\n                return v;\r\n            }else if(cmp==0){\r\n                //value exists,ignore this node\r\n                return x.getValue();\r\n            }\r\n\r\n            setParent(node,x);\r\n\r\n            if(cmp>0){\r\n                x.setLeft(node);\r\n            }else{\r\n                x.setRight(node);\r\n            }\r\n\r\n            fixInsert(node);\r\n            size.incrementAndGet();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * find the parent node to hold node x,if parent value equals x.value return parent.\r\n     * @param x\r\n     * @return\r\n     */\r\n    private RBTreeNode<T> findParentNode(RBTreeNode<T> x){\r\n        RBTreeNode<T> dataRoot = getRoot();\r\n        RBTreeNode<T> child = dataRoot;\r\n\r\n        while(child!=null){\r\n            int cmp = child.getValue().compareTo(x.getValue());\r\n            if(cmp==0){\r\n                return child;\r\n            }\r\n            if(cmp>0){\r\n                dataRoot = child;\r\n                child = child.getLeft();\r\n            }else if(cmp<0){\r\n                dataRoot = child;\r\n                child = child.getRight();\r\n            }\r\n        }\r\n        return dataRoot;\r\n    }\r\n\r\n    /**\r\n     * red black tree insert fix.\r\n     * @param x\r\n     */\r\n    private void fixInsert(RBTreeNode<T> x){\r\n        RBTreeNode<T> parent = x.getParent();\r\n\r\n        while(parent!=null && parent.isRed()){\r\n            RBTreeNode<T> uncle = getUncle(x);\r\n            if(uncle==null||!uncle.isRed()){//need to rotate\r\n                RBTreeNode<T> ancestor = parent.getParent();\r\n                //ancestor is not null due to before before add,tree color is balance\r\n                if(parent == ancestor.getLeft()){\r\n                    boolean isRight = x == parent.getRight();\r\n                    if(isRight){\r\n                        rotateLeft(parent);\r\n                    }\r\n                    rotateRight(ancestor);\r\n\r\n                    if(isRight){\r\n                        x.setRed(false);\r\n                        parent=null;//end loop\r\n                    }else{\r\n                        parent.setRed(false);\r\n                    }\r\n                    ancestor.setRed(true);\r\n                }else{\r\n                    boolean isLeft = x == parent.getLeft();\r\n                    if(isLeft){\r\n                        rotateRight(parent);\r\n                    }\r\n                    rotateLeft(ancestor);\r\n\r\n                    if(isLeft){\r\n                        x.setRed(false);\r\n                        parent=null;//end loop\r\n                    }else{\r\n                        parent.setRed(false);\r\n                    }\r\n                    ancestor.setRed(true);\r\n                }\r\n            }else{//uncle is red\r\n                parent.setRed(false);\r\n                uncle.setRed(false);\r\n                parent.getParent().setRed(true);\r\n                x=parent.getParent();\r\n                parent = x.getParent();\r\n            }\r\n        }\r\n        getRoot().makeBlack();\r\n        getRoot().setParent(null);\r\n    }\r\n    /**\r\n     * get uncle node\r\n     * @param node\r\n     * @return\r\n     */\r\n    private RBTreeNode<T> getUncle(RBTreeNode<T> node){\r\n        RBTreeNode<T> parent = node.getParent();\r\n        RBTreeNode<T> ancestor = parent.getParent();\r\n        if(ancestor==null){\r\n            return null;\r\n        }\r\n        if(parent == ancestor.getLeft()){\r\n            return ancestor.getRight();\r\n        }else{\r\n            return ancestor.getLeft();\r\n        }\r\n    }\r\n\r\n    private void rotateLeft(RBTreeNode<T> node){\r\n        RBTreeNode<T> right = node.getRight();\r\n        if(right==null){\r\n            throw new java.lang.IllegalStateException(\"right node is null\");\r\n        }\r\n        RBTreeNode<T> parent = node.getParent();\r\n        node.setRight(right.getLeft());\r\n        setParent(right.getLeft(),node);\r\n\r\n        right.setLeft(node);\r\n        setParent(node,right);\r\n\r\n        if(parent==null){//node pointer to root\r\n            //right  raise to root node\r\n            root.setLeft(right);\r\n            setParent(right,null);\r\n        }else{\r\n            if(parent.getLeft()==node){\r\n                parent.setLeft(right);\r\n            }else{\r\n                parent.setRight(right);\r\n            }\r\n            //right.setParent(parent);\r\n            setParent(right,parent);\r\n        }\r\n    }\r\n\r\n    private void rotateRight(RBTreeNode<T> node){\r\n        RBTreeNode<T> left = node.getLeft();\r\n        if(left==null){\r\n            throw new java.lang.IllegalStateException(\"left node is null\");\r\n        }\r\n        RBTreeNode<T> parent = node.getParent();\r\n        node.setLeft(left.getRight());\r\n        setParent(left.getRight(),node);\r\n\r\n        left.setRight(node);\r\n        setParent(node,left);\r\n\r\n        if(parent==null){\r\n            root.setLeft(left);\r\n            setParent(left,null);\r\n        }else{\r\n            if(parent.getLeft()==node){\r\n                parent.setLeft(left);\r\n            }else{\r\n                parent.setRight(left);\r\n            }\r\n            setParent(left,parent);\r\n        }\r\n    }\r\n\r\n\r\n    private void setParent(RBTreeNode<T> node,RBTreeNode<T> parent){\r\n        if(node!=null){\r\n            node.setParent(parent);\r\n            if(parent==root){\r\n                node.setParent(null);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove the node by give value,if this value not exists in tree return null\r\n     * @param value include search key\r\n     * @return the value contain in the removed node\r\n     */\r\n    public T remove(T value){\r\n        RBTreeNode<T> dataRoot = getRoot();\r\n        RBTreeNode<T> parent = root;\r\n\r\n        while(dataRoot!=null){\r\n            int cmp = dataRoot.getValue().compareTo(value);\r\n            if(cmp<0){\r\n                parent = dataRoot;\r\n                dataRoot = dataRoot.getRight();\r\n            }else if(cmp>0){\r\n                parent = dataRoot;\r\n                dataRoot = dataRoot.getLeft();\r\n            }else{\r\n                if(dataRoot.getRight()!=null){\r\n                    //右节点不为null\r\n                    RBTreeNode<T> min = removeMin(dataRoot.getRight());\r\n                    //x used for fix color balance\r\n                    RBTreeNode<T> x = min.getRight()==null ? min.getParent() : min.getRight();\r\n                    boolean isParent = min.getRight()==null;\r\n                    //min一定是没有左子树的，因为removeMin里已经判断了。\r\n                    //把待删除结点的左子树给到min的左子树的位置\r\n                    min.setLeft(dataRoot.getLeft());\r\n                    setParent(dataRoot.getLeft(),min);\r\n                    //设置待删除结点的父节点的指针\r\n                    if(parent.getLeft()==dataRoot){\r\n                        parent.setLeft(min);\r\n                    }else{\r\n                        parent.setRight(min);\r\n                    }\r\n                    setParent(min,parent);\r\n\r\n                    boolean curMinIsBlack = min.isBlack();\r\n                    //min结点继承待删除结点的颜色\r\n                    min.setRed(dataRoot.isRed());\r\n                    //如果min不是待删除节点的右节点\r\n                    //则把待删除结点的右子树设置到min的右子树当中\r\n                    if(min!=dataRoot.getRight()){\r\n                        min.setRight(dataRoot.getRight());\r\n                        setParent(dataRoot.getRight(),min);\r\n                    }\r\n                    //remove a black node,need fix color\r\n                    if(curMinIsBlack){\r\n                        if(min!=dataRoot.getRight()){\r\n                            fixRemove(x,isParent);\r\n                        }else if(min.getRight()!=null){\r\n                            fixRemove(min.getRight(),false);\r\n                        }else{\r\n                            fixRemove(min,true);\r\n                        }\r\n                    }\r\n                }else{\r\n                    //右节点为null的情况\r\n                    //将待删除结点的左子树给待删除结点的parent\r\n                    //因为待删除结点的右子树为空，所以不用管\r\n                    setParent(dataRoot.getLeft(),parent);\r\n                    if(parent.getLeft()==dataRoot){\r\n                        parent.setLeft(dataRoot.getLeft());\r\n                    }else{\r\n                        parent.setRight(dataRoot.getLeft());\r\n                    }\r\n                    //如果当前删除的结点是黑色的，而且树是非空的，那么就需要调整\r\n                    if(dataRoot.isBlack() && !(root.getLeft()==null)){\r\n                        RBTreeNode<T> x = dataRoot.getLeft()==null\r\n                                ? parent :dataRoot.getLeft();\r\n                        //isParent是判断是否是叶子结点，为true就是叶子结点\r\n                        boolean isParent = dataRoot.getLeft()==null;\r\n                        fixRemove(x,isParent);\r\n                    }\r\n                }\r\n                //清除待删除结点的所有指针，方便垃圾回收\r\n                setParent(dataRoot,null);\r\n                dataRoot.setLeft(null);\r\n                dataRoot.setRight(null);\r\n                //将根节点置为黑色结点\r\n                if(getRoot()!=null){\r\n                    getRoot().setRed(false);\r\n                    getRoot().setParent(null);\r\n                }\r\n                //删除了一个结点之后就进行自减\r\n                size.decrementAndGet();\r\n                //返回已删除结点的值\r\n                return dataRoot.getValue();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 删除结点操作的\r\n     * fix remove action\r\n     * @param node\r\n     * @param isParent\r\n     */\r\n    private void fixRemove(RBTreeNode<T> node,boolean isParent){\r\n        RBTreeNode<T> cur = isParent ? null : node;\r\n        boolean isRed = isParent ? false : node.isRed();\r\n        RBTreeNode<T> parent = isParent ? node : node.getParent();\r\n\r\n        while(!isRed && !isRoot(cur)){\r\n            RBTreeNode<T> sibling = getSibling(cur,parent);\r\n            //sibling is not null,due to before remove tree color is balance\r\n\r\n            //if cur is a left node\r\n            boolean isLeft = parent.getRight()==sibling;\r\n            if(sibling.isRed() && !isLeft){//case 1\r\n                //cur in right\r\n                parent.makeRed();\r\n                sibling.makeBlack();\r\n                rotateRight(parent);\r\n            }else if(sibling.isRed() && isLeft){\r\n                //cur in left\r\n                parent.makeRed();\r\n                sibling.makeBlack();\r\n                rotateLeft(parent);\r\n            }else if(isBlack(sibling.getLeft()) && isBlack(sibling.getRight())){//case 2\r\n                sibling.makeRed();\r\n                cur = parent;\r\n                isRed = cur.isRed();\r\n                parent=parent.getParent();\r\n            }else if(isLeft && !isBlack(sibling.getLeft())\r\n                    && isBlack(sibling.getRight())){//case 3\r\n                sibling.makeRed();\r\n                sibling.getLeft().makeBlack();\r\n                rotateRight(sibling);\r\n            }else if(!isLeft && !isBlack(sibling.getRight())\r\n                    && isBlack(sibling.getLeft()) ){\r\n                sibling.makeRed();\r\n                sibling.getRight().makeBlack();\r\n                rotateLeft(sibling);\r\n            }else if(isLeft && !isBlack(sibling.getRight())){//case 4\r\n                sibling.setRed(parent.isRed());\r\n                parent.makeBlack();\r\n                sibling.getRight().makeBlack();\r\n                rotateLeft(parent);\r\n                cur=getRoot();\r\n            }else if(!isLeft && !isBlack(sibling.getLeft())){\r\n                sibling.setRed(parent.isRed());\r\n                parent.makeBlack();\r\n                sibling.getLeft().makeBlack();\r\n                rotateRight(parent);\r\n                cur=getRoot();\r\n            }\r\n        }\r\n        if(isRed){\r\n            cur.makeBlack();\r\n        }\r\n        if(getRoot()!=null){\r\n            getRoot().setRed(false);\r\n            getRoot().setParent(null);\r\n        }\r\n\r\n    }\r\n\r\n    private boolean isBlack(RBTreeNode<T> node){\r\n        return node==null || node.isBlack();\r\n    }\r\n    private boolean isRoot(RBTreeNode<T> node){\r\n        return root.getLeft() == node && node.getParent()==null;\r\n    }\r\n\r\n    //get sibling node\r\n    private RBTreeNode<T> getSibling(RBTreeNode<T> node,RBTreeNode<T> parent){\r\n        parent = node==null ? parent : node.getParent();\r\n        if(node==null){\r\n            return parent.getLeft()==null ? parent.getRight() : parent.getLeft();\r\n        }\r\n        if(node==parent.getLeft()){\r\n            return parent.getRight();\r\n        }else{\r\n            return parent.getLeft();\r\n        }\r\n    }\r\n    /**\r\n     * 找到中序遍历下的下一个结点\r\n     * @param node 当前结点的右子树\r\n     * @return\r\n     */\r\n    private RBTreeNode<T> removeMin(RBTreeNode<T> node){\r\n        //find the min node\r\n        //这里是找最小的中序遍历下的后继结点\r\n        RBTreeNode<T> parent = node;\r\n        while(node!=null && node.getLeft()!=null){\r\n            parent = node;\r\n            node = node.getLeft();\r\n        }\r\n        //remove min node\r\n        if(parent==node){\r\n            return node;\r\n        }\r\n        //如果找到的node不是parent，那么改变指向\r\n        //其实就是去掉node结点，node结点肯定是没有left子树，将它的右孩子给到parent\r\n        //的左孩子\r\n        parent.setLeft(node.getRight());\r\n        setParent(node.getRight(),parent);\r\n\r\n        //don't remove right pointer,it is used for fixed color balance\r\n        //node.setRight(null);\r\n        return node;\r\n    }\r\n\r\n\r\n    /**\r\n     * debug method,it used print the given node and its children nodes,\r\n     * every layer output in one line\r\n     * @param root\r\n     */\r\n    public void printTree(RBTreeNode<T> root){\r\n        java.util.LinkedList<RBTreeNode<T>> queue =new java.util.LinkedList<RBTreeNode<T>>();\r\n        java.util.LinkedList<RBTreeNode<T>> queue2 =new java.util.LinkedList<RBTreeNode<T>>();\r\n        if(root==null){\r\n            return ;\r\n        }\r\n        queue.add(root);\r\n        boolean firstQueue = true;\r\n\r\n        while(!queue.isEmpty() || !queue2.isEmpty()){\r\n            java.util.LinkedList<RBTreeNode<T>> q = firstQueue ? queue : queue2;\r\n            RBTreeNode<T> n = q.poll();\r\n\r\n            if(n!=null){\r\n                String pos = n.getParent()==null ? \"\" : ( n == n.getParent().getLeft()\r\n                        ? \" LE\" : \" RI\");\r\n                String pstr = n.getParent()==null ? \"\" : n.getParent().toString();\r\n                String cstr = n.isRed()?\"R\":\"B\";\r\n                cstr = n.getParent()==null ? cstr : cstr+\" \";\r\n                System.out.print(n+\"(\"+(cstr)+pstr+(pos)+\")\"+\"\\t\");\r\n                if(n.getLeft()!=null){\r\n                    (firstQueue ? queue2 : queue).add(n.getLeft());\r\n                }\r\n                if(n.getRight()!=null){\r\n                    (firstQueue ? queue2 : queue).add(n.getRight());\r\n                }\r\n            }else{\r\n                System.out.println();\r\n                firstQueue = !firstQueue;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n//        RBTree<String> bst = new RBTree<String>();\r\n//        bst.addNode(\"d\");\r\n//        bst.addNode(\"d\");\r\n//        bst.addNode(\"c\");\r\n//        bst.addNode(\"c\");\r\n//        bst.addNode(\"b\");\r\n//        bst.addNode(\"f\");\r\n//\r\n//        bst.addNode(\"a\");\r\n//        bst.addNode(\"e\");\r\n//\r\n//        bst.addNode(\"g\");\r\n//        bst.addNode(\"h\");\r\n//\r\n//\r\n//        bst.printTree(bst.getRoot());\r\n        RBTree<Integer> bst = new RBTree<Integer>();\r\n        bst.addNode(44);\r\n        bst.addNode(43);\r\n        bst.addNode(42);\r\n        bst.addNode(41);\r\n        bst.addNode(40);\r\n        bst.addNode(39);\r\n//\r\n        bst.addNode(38);\r\n        bst.addNode(37);\r\n\r\n//        bst.addNode(36);\r\n//        bst.addNode(35);\r\n\r\n        bst.printTree(bst.getRoot());\r\n\r\n        System.out.println(\"-------------------------\");\r\n        bst.remove(44);\r\n        bst.printTree(bst.getRoot());\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/zzb/test/RBTree.java b/src/main/java/com/zzb/test/RBTree.java
--- a/src/main/java/com/zzb/test/RBTree.java	(revision 58bf2c24de06446587e43b37c3fc7cd57b923434)
+++ b/src/main/java/com/zzb/test/RBTree.java	(date 1619791491721)
@@ -434,10 +434,10 @@
     }
 
     /**
-     * 删除结点操作的
+     * 删除结点的修复操作
      * fix remove action
-     * @param node
-     * @param isParent
+     * @param node 修复的结点
+     * @param isParent node是否是被删除结点的父节点 true-是 非true-否
      */
     private void fixRemove(RBTreeNode<T> node,boolean isParent){
         RBTreeNode<T> cur = isParent ? null : node;
